# 이진트리가 skewed tree 가 되어 O(h)의 성능이 매우 나빠지는것을 방지하기 위해 존재

# 방법이 여러가지 있음, 단점은 자료양이 커지면 삽입삭제탐색의 효율성을 위한 재배치 시간이 오래걸릴 수 있음
# 삽입 삭제가 빈번하지 않은경우 균형이진탐색트리를 사용해 삽입, 삭제 시 재배치를통해 O(longn)의 시간을 유지할 수 있음 (skewed tree 가 되는경우 O(n)만큼시간소요)

# 전체 트리의 균형을 맞추는법 (트리의 높이를 작게)
# 균형탐색트리의 roatation right 인경우 우측아래방향으로 회전
# => 좌측 height 가 -1 우측이 +1 이 됨 결국

#rotate 는 O(1) 시간내에 완료 가능하다



# AVL 트리
# 모든 노드에 대해 왼쪽 부트리 높이와 오른쪽 부트리 높이의 차이가 1이하인 트리
# 적절한 위치에 삽입 한 후 
# AVL 트리를 만족하지 못한다면 
# 하나씩 노드를 올려가면서 balance 가 안맞는걸 맞춰야함

# 1. insert
# v = super.insert(key)  v는 insert하는 노드
# find x y z      z: 좌우 하위노드의 균형이 맞지 않는 노드
# w = rebalance(x,y,z)
# w == root: root 변경

# 로테이션 할 때 좌측 아래로 일자 형태로 뻗은경우 우측방향으로 돌리면 되는떼
# 지그재그인경우 일자 형태로 쫙 피고 로테이션 돌려야함 (두번하면 됨)

# => 결국 AVL 트리의 경우 1회 또는 2회의 로테이션만 하면 균형을 맞출 수 있음


# 2. delete
# 이것도 결국 균형이 맞지않는 노드를 z로 설정하고 height가 더 무거운쪽으로 두번 이동해서 x , y 값을 지정해준다
# 하위 노드를 로테이션해서 상위 노드의 AVL 이 맞지 않을 수 있기때문에
# 로테이션을 O(logn)// O(h) 번 만큼 할 수 있다.
